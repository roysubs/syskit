#!/bin/bash
# Author: Roy Wiseman 2025-01
# Cross-platform compatibility fix for macOS/Linux

# Git Tool Script
# Provides utilities for common Git operations and troubleshooting.

if ! command -v git &>/dev/null; then
    read -p "git not found. Install (y/N)? " -n 1 -r REPLY && echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        if [[ "$OSTYPE" == "darwin"* ]]; then
            if command -v brew &>/dev/null; then
                brew install git
            else
                echo "Homebrew not found. Please install git or Homebrew manually."
                exit 1
            fi
        else
            sudo apt update && sudo apt install -y git
        fi
    else
        echo "git not installed. Exiting."; exit 1;
    fi
fi

# Store the directory where the script was invoked
INVOCATION_DIR="$(pwd)"

# --- Helper Functions ---

echo_blue() { echo -e "\033[1;34m$@\033[0m"; }
echo_green() { echo -e "\033[1;32m$@\033[0m"; }
echo_red() { echo -e "\033[1;31m$@\033[0m"; }
echo_yellow() { echo -e "\033[1;33m$@\033[0m"; }

display_and_run() {
    echo -e "\033[1;34m$@\033[0m" # Echo the command
    eval "$@" # Execute the command
}

print_git_status_legend() {
    local C_NORMAL="\033[0m"
    local C_BOLD="\033[1m"
    local C_RED="\033[0;31m"
    local C_GREEN="\033[0;32m"
    local C_YELLOW="\033[0;33m"
    local C_BLUE="\033[0;34m"
    local C_MAGENTA="\033[0;35m"
    local C_CYAN="\033[0;36m"
    local C_BOLD_RED="\033[1;31m"
    local C_BOLD_GREEN="\033[1;32m"
    local C_BOLD_YELLOW="\033[1;33m"
    local C_BOLD_BLUE="\033[1;34m"
    local C_BOLD_MAGENTA="\033[1;35m"
    local C_BOLD_CYAN="\033[1;36m"

    local C_USER_MODIFIED="${C_BOLD_YELLOW}M${C_NORMAL}"
    local C_USER_ADDED="${C_BOLD_GREEN}A${C_NORMAL}"
    local C_USER_DELETED="${C_BOLD_RED}D${C_NORMAL}"
    local C_USER_RENAMED="${C_BOLD_MAGENTA}R${C_NORMAL}"
    local C_USER_UNTRACKED="${C_BOLD_CYAN}??${C_NORMAL}"

    local C_EX_M_MOD="${C_BOLD_RED}M${C_NORMAL}"
    local C_EX_A_ADD="${C_BOLD_GREEN}A${C_NORMAL}"
    local C_EX_QQ_UNTRK="${C_BOLD_CYAN}??${C_NORMAL}"
    local C_EX_UU_CONF="${C_BOLD_RED}UU${C_NORMAL}"

    local L1_ICON="${C_BOLD_BLUE}üîç${C_NORMAL}"
    local L1_TEXT1="'git status --short' codes: ${C_BOLD_GREEN}X${C_NORMAL}${C_BOLD_RED}Y${C_NORMAL} PATH (${C_BOLD_GREEN}X${C_NORMAL}=Staged, ${C_BOLD_RED}Y${C_NORMAL}=Unstaged). Codes:"
    local L1_CODES="${C_USER_MODIFIED}=Mod ${C_USER_ADDED}=Add ${C_USER_DELETED}=Del ${C_USER_RENAMED}=Ren ${C_USER_UNTRACKED}=Untrk"
    local L2_STAGED="${C_BOLD_GREEN}Staged (Index)${C_NORMAL}:      Changes prepared for 'git commit'."
    local L2_UNSTAGED="${C_BOLD_RED}Unstaged (Worktree)${C_NORMAL}: File modifications not yet staged for commit."

    local EX_M_S_DESC="Staged Mod:"   ; local EX_M_S_CODE="${C_EX_M_MOD} "
    local EX_M_U_DESC="Unstaged Mod:" ; local EX_M_U_CODE=" ${C_EX_M_MOD}"
    local EX_MM_DESC="Both Mod:"      ; local EX_MM_CODE="${C_EX_M_MOD}${C_EX_M_MOD}"
    local EX_A_S_DESC="Staged Add:"   ; local EX_A_S_CODE="${C_EX_A_ADD} "
    local EX_QQ_DESC="Untracked:"    ; local EX_QQ_CODE="${C_EX_QQ_UNTRK}"
    local EX_UU_DESC="Conflict:"     ; local EX_UU_CODE="${C_EX_UU_CONF}"

    echo
    echo -e "${L1_ICON} ${L1_TEXT1} ${L1_CODES}"
    echo -e "  ${L2_STAGED}"
    echo -e "  ${L2_UNSTAGED}"
    echo -e "  ${C_BOLD_BLUE}e.g.${C_NORMAL}"
    echo -e "    $(printf "%-14s%-15b | %-14s%-15b | %-12s%-15b" "$EX_M_S_DESC" "$EX_M_S_CODE" "$EX_M_U_DESC" "$EX_M_U_CODE" "$EX_MM_DESC" "$EX_MM_CODE")"
    echo -e "    $(printf "%-14s%-15b | %-14s%-15b | %-12s%-15b" "$EX_A_S_DESC" "$EX_A_S_CODE" "$EX_QQ_DESC" "$EX_QQ_CODE" "$EX_UU_DESC" "$EX_UU_CODE")"
}

# --- Usage Logic ---

if [ $# -eq 0 ]; then
    echo "Git Tool. Usage: g [option] <args>"
    echo "Options:"
    echo "  acp <message>         Add-Commit-Push: status, add -A, basic secret scan, commit -m <message>, push"
    echo "                         Also accepts --debug to show ssh -v output during the push operation"
    echo "  a                     Add All: git add .  (Stage all changes in current folder only)"
    echo "  A                     Add All: git add -A  (Stage all changes from root of repo)"
    echo "  c <message>           Commit:  git commit -m <message>"
    echo "  s                     Status:  Show the current repository status (git status)"
    echo "  ss                    Status Short: git status --short"
    echo "  set-git <ssh_url>     Change current repo's 'origin' remote URL to the provided SSH URL."
    echo "  ps|push               Push: Update to the current branch's upstream (git push)"
    echo "  pl|pull               Pull: Update latest changes from the remote to local"
    echo "  cl|clone <url> [dir]  Clone a full project from a git repository and report stats"
    echo "  cl1 <url> [dir]       Clone, but with max depth 1 only, and report stats"
    echo "  d|diff                Diff: Show unstaged changes (git diff)"
    echo "  ds                    Diff Staged: Show staged changes (git diff --staged)"
    echo "  lshort                Log with history in short format (git log --oneline --graph --decorate --all)"
    echo "  ldiffs                Log with full history and diffs (git log --stat --patch)"
    echo "  lfiles                Log show status of files changed (git log --name-status --pretty)"
    echo "  b|branch              Branch: List branches, highlight current branch"
    echo "  ch|co|checkout <br>   Checkout: Switch to a different branch"
    echo "  nb <name>             New Branch: Create and switch to a new branch"
    echo "  rpo                   Prune Remote Origin: git remote prune origin"
    echo "  f                     Fetch: Update remote refs without merging (git fetch)"
    echo "  m <branch>            Merge: Merge the specified branch into the current one"
    echo "  rs <commit>           Reset Soft: Reset to commit but keep changes (git reset --soft <commit>)"
    echo "  rh <commit>           Reset Hard: Reset to commit and discard changes (git reset --hard <commit>)"
    echo "  stash                 Stash: Save uncommitted changes (git stash)"
    echo "  stpush <message>      Stash with a message (git stash push -m <message>)"
    echo "  stpop                 Pop last stash (git stash pop)"
    echo "  clear                 Clean untracked files and directories (git clean -fd DANGEROUS!)"
    echo "  t                     Troubleshooting Help: Show common Git fixes"
    echo
    exit 0
fi

option=$1
shift

# --- Repo Context Handling ---

case "$option" in
    cl|clone|cl1)
        if [ "$(pwd)" != "$INVOCATION_DIR" ]; then
            cd "$INVOCATION_DIR" || { echo_red "‚ùå Error: Could not return to invocation directory."; exit 1; }
        fi
        ;;
    a|A|c|s|ss|acp|ps|push|pl|pull|d|diff|ds|lshort|ldiffs|lfiles|b|branch|ch|co|checkout|nb|rpo|f|m|rs|rh|stash|stpush|stpop|clear|set-git|t)
        TARGET_PROJECT_ROOT="$(git -C "$INVOCATION_DIR" rev-parse --show-toplevel 2>/dev/null)"
        if [ -n "$TARGET_PROJECT_ROOT" ] && [ -d "$TARGET_PROJECT_ROOT" ]; then
            cd "$TARGET_PROJECT_ROOT" || { echo_red "‚ùå Error: Could not change to project root."; exit 1; }
        else
            if [[ "$option" == "t" || ("$option" == "set-git" && -z "$1") ]]; then
                if [ "$(pwd)" != "$INVOCATION_DIR" ]; then cd "$INVOCATION_DIR" || exit 1; fi
            else
                echo_red "‚ùå Error: Not a Git repository."
                exit 1
            fi
        fi
        ;;
esac

# --- Command Implementation ---

case "$option" in
    a) display_and_run git add . ;;
    A) display_and_run git add -A ;;
    cl|clone|cl1)
        INPUT_URL="$1"
        if [ -z "$INPUT_URL" ]; then echo_red "‚ùå Error: URL required."; exit 1; fi
        if [[ "$INPUT_URL" =~ ^gl/ ]]; then
            REPO_URL="https://gitlab.com/${INPUT_URL#gl/}"
        elif [[ "$INPUT_URL" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_.-]+$ && ! "$INPUT_URL" =~ :// && ! "$INPUT_URL" =~ @ ]]; then
            REPO_URL="https://github.com/${INPUT_URL}"
        else
            REPO_URL="$INPUT_URL"
        fi
        CLONE_DIR=$(echo "$REPO_URL" | sed -E 's/.*\/([^/]+)(\.git)?$/\1/')
        CLONE_ARGS_ARRAY=("$REPO_URL")
        TEMP_ARGS=("$@")
        unset TEMP_ARGS[0]
        for arg in "${TEMP_ARGS[@]}"; do CLONE_ARGS_ARRAY+=("$arg"); done
        if [ "$option" = "cl1" ]; then CLONE_ARGS_ARRAY+=("--depth=1"); fi
        display_and_run "git clone ${CLONE_ARGS_ARRAY[*]}"
        if [ $? -eq 0 ]; then
            ACTUAL_CLONE_DIR_NAME="${CLONE_ARGS_ARRAY[1]:-$CLONE_DIR}"
            if [ -d "$ACTUAL_CLONE_DIR_NAME" ]; then
                cd "$ACTUAL_CLONE_DIR_NAME"
                echo_blue "Stats: $(find . -type f | wc -l | tr -d ' ') files, $(find . -type d -mindepth 1 | wc -l | tr -d ' ') folders, $(du -sh . | cut -f1)"
                cd "$INVOCATION_DIR"
            fi
        fi
        ;;
    c) [ -z "$1" ] && { echo_red "‚ùå Error: Message required."; exit 1; }; display_and_run git commit -m "$@" ;;
    s) display_and_run git status; print_git_status_legend ;;
    ss) display_and_run git status --short; print_git_status_legend ;;
    acp)
        DEBUG_MODE=0
        COMMIT_MSG_PARTS=()
        TEMP_ACP_ARGS=("$@")
        for arg in "${TEMP_ACP_ARGS[@]}"; do
            [[ "$arg" == "--debug" ]] && DEBUG_MODE=1 || COMMIT_MSG_PARTS+=("$arg")
        done
        COMMIT_STR="${COMMIT_MSG_PARTS[*]:-Various}"
        if [[ ${#COMMIT_MSG_PARTS[@]} -eq 0 ]]; then echo_yellow "‚ÑπÔ∏è No commit message provided. Using default: \"$COMMIT_STR\""; fi
        
        echo "====="
        display_and_run git status --short
        echo "====="
        display_and_run git add -A --verbose
        if git diff --staged --quiet; then echo_green "‚úÖ No changes staged to commit."; exit 0; fi

        # --- Portable Secret Scan Fix ---
        echo "====="
        echo "Scanning tracked files for potential secrets..."
        repo_root=$(git rev-parse --show-toplevel 2>/dev/null)
        SCAN_FILES_TEMP_FILE=$(mktemp /tmp/scan_files.XXXXXX)
        trap 'rm -f "$SCAN_FILES_TEMP_FILE" 2>/dev/null' EXIT
        
        git -C "$repo_root" ls-files -z | while IFS= read -r -d $'\0' file; do
            if ! git -C "$repo_root" check-ignore -q -- "$file" 2>/dev/null; then
                printf "%s\0" "$file" >> "$SCAN_FILES_TEMP_FILE"
            fi
        done

        POTENTIAL_SECRETS_FOUND=0
        if [ -s "$SCAN_FILES_TEMP_FILE" ]; then
            echo "Checking for GitHub tokens..."
            # FIXED: Removed incompatible macOS flags -a and -r
            if xargs -0 < "$SCAN_FILES_TEMP_FILE" git -C "$repo_root" grep -E --line-number --color=always -e 'gh[pusr]_[a-zA-Z0-9]{36}' --; then
                POTENTIAL_SECRETS_FOUND=1
            fi
            echo "Checking for generic keys..."
            # FIXED: Portable xargs redirection
            xargs -0 < "$SCAN_FILES_TEMP_FILE" git -C "$repo_root" grep -iE --line-number --color=always -e '(API_KEY|SECRET_KEY|JWT_SECRET|PRIVATE_KEY|ACCESS_TOKEN|CLIENT_SECRET|AUTH_TOKEN|SESSION_KEY|TOKEN)\s*[:=]\s*["'\'']?[A-Za-z0-9\-_/+]{20,}' -- | grep -vEi '=(YOUR|PLACEHOLDER|DUMMY|EXAMPLE|ENTER|PASTE)'
        fi
        # --- End Portable Scan ---

        echo "--------------------------------------------------"
        echo_blue "‚ÑπÔ∏è You are about to commit to: $(pwd)"
        echo_blue "    Remote: $(git config --get remote.origin.url 2>/dev/null)"
        echo "--------------------------------------------------"
        read -rp "Do you want to commit these changes with message \"$COMMIT_STR\"? [y/N]: " confirm_commit
        [[ ! "$confirm_commit" =~ ^[Yy]$ ]] && { echo_yellow "Commit cancelled."; exit 1; }

        commit_output=$(git commit --verbose -m "$COMMIT_STR" 2>&1)
        commit_status=$?
        echo "$commit_output"
        if [ $commit_status -eq 0 ]; then
            echo_green "‚úÖ New commit created."
            CURRENT_BRANCH=$(git symbolic-ref --short HEAD 2>/dev/null)
            echo_yellow "VPN check: Consider disconnecting VPN for push."
            if [[ $DEBUG_MODE -eq 1 ]]; then
                display_and_run env GIT_SSH_COMMAND='ssh -v' git push origin "$CURRENT_BRANCH"
            else
                read -rp "‚úÖ Ready to push to origin/$CURRENT_BRANCH ‚Äî press ENTER to confirm... "
                display_and_run git push origin "$CURRENT_BRANCH"
            fi
        fi
        ;;
    ps|push) display_and_run git push ;;
    pl|pull)
        echo_blue "üì° Fetching..."
        display_and_run "git fetch"
        LOCAL_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
        REMOTE_BRANCH="origin/$LOCAL_BRANCH"
        if git show-ref --verify --quiet "refs/remotes/$REMOTE_BRANCH"; then
            display_and_run "git diff --name-status $LOCAL_BRANCH...$REMOTE_BRANCH"
            read -rp "üîç Review full diffs? (y/N): " confirm_diff
            [[ "$confirm_diff" =~ ^[Yy]$ ]] && git diff "$LOCAL_BRANCH...$REMOTE_BRANCH"
            read -rp "‚ùì Pull (fast-forward only)? (Y/n): " confirm_pull
            [[ ! "$confirm_pull" =~ ^[Nn]$ ]] && display_and_run "git pull --ff-only origin $LOCAL_BRANCH"
        else
            display_and_run "git pull"
        fi
        ;;
    d|diff) display_and_run git diff ;;
    ds) display_and_run git diff --staged ;;
    lshort) display_and_run git log --oneline --graph --decorate --all ;;
    ldiffs) display_and_run git log --stat --patch ;;
    lfiles) display_and_run git log --name-status --pretty=format:"%C(auto)%h %<(20)%ad %<(15)%an %d %s" --date=short ;;
    b|branch) display_and_run git branch --sort=-committerdate --color=always | sed -e '/^\*/!s/^/  /' ;;
    ch|co|checkout) [ -z "$1" ] && { echo_red "‚ùå Branch required."; exit 1; }; display_and_run git checkout "$1" ;;
    nb) [ -z "$1" ] && { echo_red "‚ùå Name required."; exit 1; }; display_and_run git checkout -b "$1" ;;
    rpo) display_and_run git remote prune origin ;;
    f) display_and_run git fetch --all --prune ;;
    m) [ -z "$1" ] && { echo_red "‚ùå Branch required."; exit 1; }; display_and_run git merge "$1" ;;
    rs) [ -z "$1" ] && { echo_red "‚ùå Hash required."; exit 1; }; display_and_run git reset --soft "$1" ;;
    rh)
        [ -z "$1" ] && { echo_red "‚ùå Hash required."; exit 1; }
        read -rp $'\033[1;31m‚ö†Ô∏è WARNING: Discard changes? (y/N):\033[0m ' confirm
        [[ "$confirm" =~ ^[Yy]$ ]] && display_and_run git reset --hard "$1" || echo_blue "Cancelled."
        ;;
    stash) display_and_run git stash ;;
    stpush) [ -z "$1" ] && { echo_red "‚ùå Message required."; exit 1; }; display_and_run git stash push -m "$@" ;;
    stpop) display_and_run git stash pop ;;
    clear)
        read -rp "‚ö†Ô∏è DANGEROUS: Clean untracked files? (Type 'yes'): " confirm
        [[ "$confirm" == "yes" ]] && display_and_run git clean -fd || echo_blue "Cancelled."
        ;;
    set-git)
        if [ -z "$1" ]; then
            echo_blue "Understanding Git Remote URLs: HTTPS vs SSH"
            echo "1. HTTPS (e.g., https://github.com/user/repo.git)"
            echo "2. SSH (e.g., git@github.com:user/repo.git) - Recommended"
            echo "Usage: g set-git <your_ssh_url>"
            git rev-parse --is-inside-work-tree > /dev/null 2>&1 && git remote -v
        else
            display_and_run git remote set-url origin "$1"
        fi
        ;;
    t)
        echo_blue "Git Troubleshooting Help:"
        echo "  - Merge conflict: Edit files, then 'git add' and 'git commit'."
        echo "  - Undo last commit (keep changes): g rs HEAD~1"
        echo "  - Undo last commit (DISCARD changes): g rh HEAD~1"
        echo "  - Detached HEAD: 'g ch <branchname>' to fix."
        echo "  - Push rejected: Pull first with 'g pl'."
        ;;
    *) echo_red "‚ùå Invalid option."; exit 1 ;;
esac
