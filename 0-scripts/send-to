#!/bin/bash

# send-to.sh - Send any file to remote host and open with default application
# Works especially well for sending files from Linux server to Windows desktop

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_color() {
    local color=$1
    shift
    echo -e "${color}$*${NC}"
}

# Function to check if a command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Function to get server's IP address that's reachable from client
get_server_ip() {
    local client_ip=$1
    # Try to determine which interface can reach the client
    ip route get "$client_ip" 2>/dev/null | grep -oP 'src \K[^ ]+' | head -1
}

# Display usage
usage() {
    cat << EOF
Usage: $0 <file> [hostname-or-ip] [options]

Send any file to a remote host and open it with the default application.
If hostname-or-ip is omitted, it will use the host you SSH'd from.

Options:
    -p, --port PORT       Port to use for file transfer (default: random 8000-8999)
    -m, --method METHOD   Transfer method: http, smb, scp (default: http)
    -t, --timeout SECS    Timeout for serving file (default: 300 seconds)
    -h, --help           Show this help message

Examples:
    $0 document.pdf                 # Send PDF to SSH client host
    $0 video.mp4 192.168.1.100     # Send video to specific host
    $0 report.docx -t 60            # Send with 60 second timeout

Notes:
    - For Windows clients, the HTTP method works best
    - Files open in the default application on the remote system
    - The script creates a temporary HTTP server to serve the file

EOF
    exit 0
}

# Parse arguments
FILE=""
REMOTE_HOST=""
PORT=""
METHOD="http"
TIMEOUT=300

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            usage
            ;;
        -p|--port)
            PORT="$2"
            shift 2
            ;;
        -m|--method)
            METHOD="$2"
            shift 2
            ;;
        -t|--timeout)
            TIMEOUT="$2"
            shift 2
            ;;
        -*)
            print_color $RED "Unknown option: $1"
            usage
            ;;
        *)
            if [ -z "$FILE" ]; then
                FILE="$1"
            elif [ -z "$REMOTE_HOST" ]; then
                REMOTE_HOST="$1"
            fi
            shift
            ;;
    esac
done

# Check if file was provided
if [ -z "$FILE" ]; then
    print_color $RED "Error: No file specified"
    usage
fi

# Check if the file exists
if [ ! -f "$FILE" ]; then
    print_color $RED "Error: File '$FILE' not found!"
    exit 1
fi

# Get absolute path and file information
FILE_PATH=$(realpath "$FILE")
FILE_NAME=$(basename "$FILE")
FILE_SIZE=$(du -h "$FILE" | cut -f1)
FILE_EXT="${FILE_NAME##*.}"

# If no host specified, try to get the SSH client's IP
if [ -z "$REMOTE_HOST" ]; then
    if [ -n "$SSH_CLIENT" ]; then
        # SSH_CLIENT format: "client_ip client_port server_port"
        REMOTE_HOST=$(echo $SSH_CLIENT | awk '{print $1}')
        print_color $GREEN "No host specified. Using SSH client IP: $REMOTE_HOST"
    else
        print_color $RED "Error: No host specified and unable to detect SSH client IP."
        print_color $YELLOW "Are you sure you're connected via SSH?"
        exit 1
    fi
fi

# Get server IP that's reachable from client
SERVER_IP=$(get_server_ip "$REMOTE_HOST")
if [ -z "$SERVER_IP" ]; then
    SERVER_IP=$(hostname -I | awk '{print $1}')
fi

# Set default port if not specified
if [ -z "$PORT" ]; then
    PORT=$((8000 + RANDOM % 1000))
fi

# Detect if remote host is Windows
IS_WINDOWS=false
if ssh -o ConnectTimeout=5 "$REMOTE_HOST" "cmd /c echo test" >/dev/null 2>&1; then
    IS_WINDOWS=true
    print_color $BLUE "Detected Windows remote host"
elif ssh -o ConnectTimeout=5 "$REMOTE_HOST" "echo test" >/dev/null 2>&1; then
    print_color $BLUE "Detected Unix-like remote host"
else
    print_color $YELLOW "Could not detect remote OS, assuming Windows"
    IS_WINDOWS=true
fi

print_color $GREEN "========================================="
print_color $GREEN "File: $FILE_NAME ($FILE_SIZE)"
print_color $GREEN "Type: .$FILE_EXT file"
print_color $GREEN "Remote Host: $REMOTE_HOST"
print_color $GREEN "Server IP: $SERVER_IP"
print_color $GREEN "Method: $METHOD"
print_color $GREEN "========================================="

# Function to serve file via HTTP and open on remote
serve_http() {
    print_color $YELLOW "Starting HTTP server on port $PORT..."
    
    # Check for Python
    if ! command_exists python3 && ! command_exists python; then
        print_color $RED "Python is required for HTTP serving but not installed."
        return 1
    fi
    
    # Create a temporary directory with the file
    local temp_dir=$(mktemp -d)
    
    # Create a simple HTML index with auto-download for easier access
    cat > "$temp_dir/index.html" << EOF
<!DOCTYPE html>
<html>
<head>
    <title>File Transfer</title>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        .container {
            background: white;
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            text-align: center;
            max-width: 500px;
        }
        h1 { color: #333; }
        .file-info {
            background: #f5f5f5;
            padding: 1rem;
            border-radius: 5px;
            margin: 1rem 0;
        }
        .download-btn {
            display: inline-block;
            padding: 12px 30px;
            background: #667eea;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-size: 18px;
            margin-top: 1rem;
            transition: background 0.3s;
        }
        .download-btn:hover {
            background: #5a67d8;
        }
        .auto-open {
            color: #666;
            margin-top: 1rem;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìÅ File Ready</h1>
        <div class="file-info">
            <strong>File:</strong> $FILE_NAME<br>
            <strong>Size:</strong> $FILE_SIZE<br>
            <strong>Type:</strong> .$FILE_EXT
        </div>
        <a href="/$FILE_NAME" download class="download-btn">Download File</a>
        <div class="auto-open">
            <p>The file should open automatically in your default application.</p>
            <p>If not, click the download button above.</p>
        </div>
    </div>
    <script>
        // Auto-download and open the file
        window.onload = function() {
            setTimeout(function() {
                window.location.href = '/$FILE_NAME';
            }, 500);
        };
    </script>
</body>
</html>
EOF
    
    # Copy or symlink the file
    cp "$FILE_PATH" "$temp_dir/$FILE_NAME"
    
    # Start HTTP server in background
    if command_exists python3; then
        (cd "$temp_dir" && python3 -m http.server $PORT --bind 0.0.0.0 >/dev/null 2>&1) &
    else
        (cd "$temp_dir" && python -m SimpleHTTPServer $PORT >/dev/null 2>&1) &
    fi
    local http_pid=$!
    
    # Give server time to start
    sleep 1
    
    # Check if server started successfully
    if ! kill -0 $http_pid 2>/dev/null; then
        print_color $RED "Failed to start HTTP server"
        rm -rf "$temp_dir"
        return 1
    fi
    
    # Construct URL
    local file_url="http://${SERVER_IP}:${PORT}/${FILE_NAME}"
    local index_url="http://${SERVER_IP}:${PORT}/"
    
    print_color $GREEN "File available at: $file_url"
    print_color $YELLOW "Opening file on remote host..."
    
    # Open on remote host based on OS
    if [ "$IS_WINDOWS" = true ]; then
        # For Windows, use PowerShell to download and open
        ssh "$REMOTE_HOST" "powershell -Command \"
            \\\$url = '$file_url'
            \\\$tempFile = [System.IO.Path]::GetTempPath() + '$FILE_NAME'
            
            Write-Host 'Downloading file...'
            try {
                \\\$webClient = New-Object System.Net.WebClient
                \\\$webClient.DownloadFile(\\\$url, \\\$tempFile)
                
                Write-Host 'Opening file with default application...'
                Start-Process \\\$tempFile
                
                Write-Host 'File opened successfully!'
                Write-Host 'Location: ' \\\$tempFile
            } catch {
                Write-Host 'Trying alternative method...'
                Start-Process '$index_url'
            }
        \"" 2>/dev/null || {
            # Fallback: Just try to open the URL directly
            ssh "$REMOTE_HOST" "cmd /c start $index_url" 2>/dev/null || {
                print_color $YELLOW "Could not auto-open file. Please open manually:"
                print_color $BLUE "  $index_url"
            }
        }
    else
        # For Unix-like systems, use wget/curl and xdg-open
        ssh "$REMOTE_HOST" "
            temp_file=\"/tmp/$FILE_NAME\"
            
            # Download file
            if command -v wget >/dev/null 2>&1; then
                echo 'Downloading with wget...'
                wget -q -O \"\$temp_file\" '$file_url'
            elif command -v curl >/dev/null 2>&1; then
                echo 'Downloading with curl...'
                curl -s -o \"\$temp_file\" '$file_url'
            else
                echo 'Opening URL directly...'
                if command -v xdg-open >/dev/null 2>&1; then
                    xdg-open '$index_url'
                elif command -v open >/dev/null 2>&1; then
                    open '$index_url'
                fi
                exit
            fi
            
            # Open file with default application
            if [ -f \"\$temp_file\" ]; then
                echo 'Opening file...'
                if command -v xdg-open >/dev/null 2>&1; then
                    xdg-open \"\$temp_file\"
                elif command -v open >/dev/null 2>&1; then
                    open \"\$temp_file\"
                else
                    echo 'File downloaded to: '\$temp_file
                fi
            fi
        " 2>/dev/null || {
            print_color $YELLOW "Please open this URL on the remote host:"
            print_color $BLUE "  $index_url"
        }
    fi
    
    # Keep server running for specified timeout
    print_color $GREEN "‚úì File sent successfully!"
    print_color $YELLOW "Server will remain active for $TIMEOUT seconds..."
    print_color $YELLOW "Press Ctrl+C to stop the server earlier"
    
    # Wait for timeout or interrupt
    local count=0
    trap "kill $http_pid 2>/dev/null; rm -rf '$temp_dir'; exit 0" INT TERM
    
    while [ $count -lt $TIMEOUT ] && kill -0 $http_pid 2>/dev/null; do
        sleep 1
        ((count++))
        
        # Show progress every 10 seconds
        if [ $((count % 10)) -eq 0 ]; then
            remaining=$((TIMEOUT - count))
            echo -ne "\rRemaining time: $remaining seconds... "
        fi
    done
    
    echo
    print_color $GREEN "Cleaning up..."
    
    # Cleanup
    kill $http_pid 2>/dev/null
    wait $http_pid 2>/dev/null
    rm -rf "$temp_dir"
}

# Function to copy via SCP and open
send_scp() {
    print_color $YELLOW "Using SCP to transfer file..."
    
    if [ "$IS_WINDOWS" = true ]; then
        # For Windows, copy to temp directory
        local remote_path="%TEMP%\\$FILE_NAME"
        local scp_path="/c/Windows/Temp/$FILE_NAME"
        
        print_color $GREEN "Copying file to Windows temp directory..."
        scp "$FILE_PATH" "${REMOTE_HOST}:${scp_path}" || {
            print_color $RED "SCP transfer failed"
            return 1
        }
        
        print_color $GREEN "Opening file on Windows..."
        ssh "$REMOTE_HOST" "cmd /c start \"\" \"%TEMP%\\$FILE_NAME\"" || {
            print_color $YELLOW "File copied but could not auto-open"
            print_color $BLUE "Location: %TEMP%\\$FILE_NAME"
        }
    else
        # For Unix-like systems
        local remote_path="/tmp/$FILE_NAME"
        
        print_color $GREEN "Copying file to remote /tmp..."
        scp "$FILE_PATH" "${REMOTE_HOST}:${remote_path}" || {
            print_color $RED "SCP transfer failed"
            return 1
        }
        
        print_color $GREEN "Opening file on remote host..."
        ssh "$REMOTE_HOST" "
            if command -v xdg-open >/dev/null 2>&1; then
                xdg-open '$remote_path'
            elif command -v open >/dev/null 2>&1; then
                open '$remote_path'
            else
                echo 'File copied to: $remote_path'
            fi
        "
    fi
}

# Function to use SMB/CIFS sharing (requires setup)
send_smb() {
    print_color $YELLOW "SMB method requires Samba to be configured on this server"
    print_color $YELLOW "And the Windows client needs to have access to the share"
    
    # Check if Samba is installed
    if ! command_exists smbd; then
        print_color $RED "Samba is not installed. Install with:"
        print_color $YELLOW "  sudo apt-get install samba"
        return 1
    fi
    
    # Get the Samba share path (this assumes a share is already configured)
    local share_name="temp_share"
    local share_path="/srv/samba/temp"
    
    print_color $GREEN "Creating temporary SMB share..."
    
    # This would require sudo and proper Samba configuration
    print_color $YELLOW "To use SMB sharing, you need to:"
    print_color $YELLOW "1. Configure Samba with a shared folder"
    print_color $YELLOW "2. Ensure Windows can access \\\\${SERVER_IP}\\sharename"
    print_color $YELLOW "3. Copy files to the share and open from Windows"
    
    print_color $BLUE "For now, falling back to HTTP method..."
    serve_http
}

# Main execution
case $METHOD in
    http)
        serve_http || {
            print_color $RED "HTTP method failed"
            exit 1
        }
        ;;
    scp)
        send_scp || {
            print_color $RED "SCP method failed"
            exit 1
        }
        ;;
    smb)
        send_smb || {
            print_color $RED "SMB method failed"
            exit 1
        }
        ;;
    *)
        print_color $RED "Invalid method: $METHOD"
        usage
        ;;
esac

print_color $GREEN "‚úì Done!"
