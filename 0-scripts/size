#!/bin/bash
# Author: Roy Wiseman (Refactored by Gemini) 2025-01
# Description: Fast directory size analyzer with dynamic column width and permission hints.

# --- Configuration ---
set -o pipefail  # Crucial: allows us to catch 'find' errors after the pipeline

# Capture original arguments for sudo re-execution
ORIG_ARGS=("$@")

# Colors
YELLOW='\033[1;33m'
GREEN='\033[1;32m'
CYAN='\033[1;36m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Defaults
target_path="."
max_depth=""     # Empty means infinite recursion
specific_ext=""  # Empty means report all
report_mode="summary" # Options: summary, breakdown
excludes=()

# --- Helper Functions ---

show_help() {
    echo -e "${CYAN}SysKit Size Analyzer${NC}"
    echo "Usage: size [options] [path]"
    echo ""
    echo "  [path]              Directory to analyze (defaults to current)."
    echo ""
    echo "Options:"
    echo "  -t, --type [ext]    Report by extension."
    echo "                      - If [ext] is provided (e.g. 'ps1'), filters only those files."
    echo "                      - If no [ext] provided, lists ALL extensions found."
    echo "  -e, --exclude <pat> Exclude file or directory pattern (can be used multiple times)."
    echo "                      Example: -e .git -e node_modules"
    echo "  -s, --sudo          Run as root (auto-executes sudo if needed)."
    echo "  -L <level>          Max depth. '-L 1' is current folder only."
    echo "  -h, --help          Show this help."
    echo ""
}

# --- Argument Parsing ---

while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
        -h|--help)
            show_help
            exit 0
            ;;
        -s|--sudo)
            if [[ $EUID -ne 0 ]]; then
                echo -e "${YELLOW}Elevating permissions...${NC}"
                exec sudo "$0" "${ORIG_ARGS[@]}"
            fi
            shift
            ;;
        -L)
            if [[ -n "$2" && "$2" =~ ^[0-9]+$ ]]; then
                max_depth="$2"
                shift 2
            else
                echo -e "${RED}Error: -L requires a number.${NC}" >&2
                exit 1
            fi
            ;;
        -t|--type)
            report_mode="breakdown"
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                specific_ext="${2#.}"
                shift 2
            else
                shift
            fi
            ;;
        -e|--exclude)
            if [[ -n "$2" ]]; then
                excludes+=("$2")
                shift 2
            else
                echo -e "${RED}Error: --exclude requires a pattern.${NC}" >&2
                exit 1
            fi
            ;;
        -*)
            echo -e "${RED}Unknown option: $1${NC}" >&2
            show_help
            exit 1
            ;;
        *)
            target_path="$1"
            shift
            ;;
    esac
done

real_path=$(realpath -s "$target_path" 2>/dev/null || echo "$target_path")

if [[ ! -e "$real_path" ]]; then
    echo -e "size: ${RED}Error: '$real_path' does not exist.${NC}" >&2
    exit 1
fi

# --- Construct the Find Command ---

cmd=(find "$real_path")

if [[ -n "$max_depth" ]]; then
    cmd+=("-maxdepth" "$max_depth")
fi

if [[ ${#excludes[@]} -gt 0 ]]; then
    cmd+=("(")
    first=true
    for pattern in "${excludes[@]}"; do
        if [ "$first" = true ]; then
            cmd+=("-name" "$pattern")
            first=false
        else
            cmd+=("-o" "-name" "$pattern")
        fi
    done
    cmd+=(")")
    cmd+=("-prune" "-o")
fi

if [[ -n "$specific_ext" ]]; then
    cmd+=("-name" "*.$specific_ext")
fi

cmd+=("-type" "f" "-printf" "%s|%f\n")

# --- Execution & Output Processing ---

"${cmd[@]}" | awk -F "|" -v mode="$report_mode" \
                  -v target_ext="$specific_ext" \
                  -v search_path="$real_path" \
                  -v yellow="$YELLOW" \
                  -v green="$GREEN" \
                  -v nc="$NC" '

    function human(x) {
        split("B KiB MiB GiB TiB", v, " ")
        s=1
        while(x>1024){x/=1024; s++}

        if (s == 1) {
            return sprintf("%.1f   %s", x, v[s])
        } else {
            return sprintf("%.1f %s", x, v[s])
        }
    }

    function comma(num,   i, res) {
        res = ""
        for (i=length(num); i>0; i--) {
            res = substr(num, i, 1) res
            if ((length(num)-i+1) % 3 == 0 && i > 1)
                res = "," res
        }
        return res
    }

    {
        bytes = $1
        filename = $2

        n = split(filename, a, ".")
        if (n > 1) {
            ext = tolower(a[n])
        } else {
            ext = "(no extension)"
        }

        total_bytes += bytes
        total_files += 1

        ext_sizes[ext] += bytes
        ext_counts[ext] += 1
    }

    END {
        if (total_files == 0) {
            print "No files found matching criteria."
            exit
        }

        # --- OUTPUT LOGIC ---

        if (target_ext != "") {
            # Specific extension mode
            print "Path: " search_path
            print "Found " yellow comma(ext_counts[target_ext]) nc " files ending in " yellow "." target_ext nc
            print "Total Size: " green human(total_bytes) nc
        }
        else if (mode == "breakdown") {
            # Breakdown Table Mode

            # 1. Calculate dynamic width for first column
            max_len = 9
            for (e in ext_sizes) {
                len = length((e == "(no extension)") ? e : "."e)
                if (len > max_len) max_len = len
            }
            max_len += 2
            fmt_str = "%-" max_len "s %12s %12s\n"

            # Print Header
            printf fmt_str, "EXTENSION", "COUNT", "SIZE"

            total_width = max_len + 26
            for(i=1; i<=total_width; i++) printf "-"
            print ""

            # 2. Print Data
            sort_cmd = "sort -k1,1nr | cut -f2-"

            for (e in ext_sizes) {
                formatted_ext = (e == "(no extension)") ? e : "."e
                printf "%s\t" fmt_str, ext_sizes[e], formatted_ext, comma(ext_counts[e]), human(ext_sizes[e]) | sort_cmd
            }
            close(sort_cmd)

            print ""
            for(i=1; i<=total_width; i++) printf "-"
            print ""
            print "Path: " search_path
            print "Total: " yellow comma(total_files) nc " files, " green human(total_bytes) nc
        }
        else {
            # Summary Mode (Default)
            print "Path: " search_path
            print "Total: " yellow comma(total_files) nc " files, " green human(total_bytes) nc
        }
    }
'

# --- Error Detection ---
pipeline_status=$?

if [[ $pipeline_status -ne 0 ]]; then
    echo ""
    echo -e "${RED}[!] Some directories could not be entered due to permissions.${NC}"
    echo -e "${RED}    Rerun with -s | --sudo to include them.${NC}"
fi
