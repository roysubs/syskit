#!/bin/bash
# Author: Roy Wiseman 2025-01

count=false
paths_arr=()
xdev_enabled=true
top_n_root_files_count=0
top_n_subdirs_count=0
top_n_subfiles_count=0
use_apparent_size_default=true # Script's default is apparent size

# --- Colors ---
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

CMD="bc"
if ! command -v $CMD &>/dev/null; then
    read -p "$CMD not found. Install (y/N)? " -n 1 -r REPLY && echo
    [[ $REPLY =~ ^[Yy]$ ]] && (sudo apt install -y $CMD) || { echo "$CMD not installed. Exiting."; exit 1; }
fi

# Help message
show_help() {
    echo "
Usage: size [options] [path(s)]

  Without arguments, shows the size of the current directory using apparent file sizes
  (excluding other mounted filesystems).
  
  Supports wildcards and multiple paths.

Options:
  -c, --count
        Also count the number of files and directories.
  -a, --all-filesystems
        Traverse all filesystems. By default, stays on the same filesystem
        as the path being processed.
  -d, --disk-usage
        Use actual disk usage (allocated blocks) instead of apparent file sizes.
        (This is the default behavior of the 'du' command itself).
  -t N, --top N
        Show the top N largest files in the specified path (not in subdirectories).
        Defaults to 10 if N is not specified.
  -ts N
        Show the top N largest subdirectories by their total size.
        Defaults to 10 if N is not specified.
  -tsf N
        Show the top N largest files found within all subdirectories.
        Defaults to 10 if N is not specified.
  -h, --help
        Show this help message.

Examples:
  size           → Show apparent size of current directory
  size -d /var   → Show disk usage of /var
  size -c /mnt   → Show apparent size + counts of /mnt
  size -t 5 /usr   → Show the 5 largest files in /usr
  size -t          → Show the 10 largest files in current directory
  size -ts 10 /home → Show the 10 largest subdirectories in /home
  size -tsf        → Show the 10 largest files in subdirectories
  size -t 5 -tsf 5 → Show largest files in current dir AND in its subdirs
  size *.py      → Show total size of all Python files
  size file1.txt file2.txt → Show combined size of multiple files
"
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            show_help
            exit 0
            ;;
        -c|--count)
            count=true
            shift
            ;;
        -a|--all-filesystems)
            xdev_enabled=false
            shift
            ;;
        -d|--disk-usage)
            use_apparent_size_default=false # User wants disk usage
            shift
            ;;
        -t|--top)
            if [[ -n "$2" && "$2" =~ ^[0-9]+$ && "$2" -gt 0 ]]; then
                top_n_root_files_count="$2"
                shift 2
            elif [[ -z "$2" || "$2" =~ ^- ]]; then
                # No number provided or next arg is an option, default to 10
                top_n_root_files_count=10
                shift
            else
                echo "Error: --top (-t) requires a positive integer argument." >&2
                exit 1
            fi
            ;;
        -ts)
            if [[ -n "$2" && "$2" =~ ^[0-9]+$ && "$2" -gt 0 ]]; then
                top_n_subdirs_count="$2"
                shift 2
            elif [[ -z "$2" || "$2" =~ ^- ]]; then
                # No number provided or next arg is an option, default to 10
                top_n_subdirs_count=10
                shift
            else
                echo "Error: -ts requires a positive integer argument." >&2
                exit 1
            fi
            ;;
        -tsf)
            if [[ -n "$2" && "$2" =~ ^[0-9]+$ && "$2" -gt 0 ]]; then
                top_n_subfiles_count="$2"
                shift 2
            elif [[ -z "$2" || "$2" =~ ^- ]]; then
                # No number provided or next arg is an option, default to 10
                top_n_subfiles_count=10
                shift
            else
                echo "Error: -tsf requires a positive integer argument." >&2
                exit 1
            fi
            ;;
        -*)
            echo "Invalid option: $1" >&2
            show_help
            exit 1
            ;;
        *)
            paths_arr+=("$1")
            shift
            ;;
    esac
done

# If no paths provided, default to current directory
if [[ ${#paths_arr[@]} -eq 0 ]]; then
    paths_arr=(".")
fi

start_time=$(date +%s.%N)

# --- Helper function to build du options ---
build_du_options() {
    local type="$1" # "summarize", or "file"
    local opts=("-h") # Always human-readable

    if [[ "$type" == "summarize" ]]; then
        opts+=("-s")
    fi # For "file", no extra structure option needed

    if [ "$xdev_enabled" = true ]; then
        opts+=("-x")
    fi

    if [ "$use_apparent_size_default" = true ]; then
        opts+=("--apparent-size")
    fi
    echo "${opts[@]}" # Return as space-separated string
}

# --- Helper function to process a single path ---
process_path() {
    local path="$1"
    
    # Resolve absolute path, stripping any trailing slash for consistency
    path=$(realpath -s "$path")
    
    # Validate path
    if [[ ! -e "$path" ]]; then
        echo "size: Error: '$path' does not exist." >&2
        return 1
    fi

    size_info=""
    is_directory=false
    is_file=false

    if [[ -d "$path" ]]; then
        is_directory=true
        read -ra current_du_opts <<< "$(build_du_options "summarize")"
        size_info=$(du "${current_du_opts[@]}" "$path" 2>/dev/null | awk '{print $1}')
    elif [[ -f "$path" ]]; then
        is_file=true
        read -ra current_du_opts <<< "$(build_du_options "file")"
        size_info=$(du "${current_du_opts[@]}" "$path" 2>/dev/null | awk '{print $1}')
    else
        echo "size: Error: '$path' is not a regular file or directory." >&2
        return 1
    fi

    if [[ -z "$size_info" ]]; then
        size_info="Permission denied or inaccessible"
    fi

    # Disk usage from df
    df_path_target="$path"
    if [[ "$is_file" = true ]]; then
        df_path_target=$(dirname "$path")
    fi
    df_output=$(df -hP "$df_path_target" 2>/dev/null | tail -n 1)
    device=$(echo "$df_output" | awk '{print $1}')
    total_size=$(echo "$df_output" | awk '{print $2}')
    used=$(echo "$df_output" | awk '{print $3}')
    available=$(echo "$df_output" | awk '{print $4}')
    use_percent=$(echo "$df_output" | awk '{print $5}')

    # --- Find options array ---
    find_opts_arr=()
    if [ "$xdev_enabled" = true ]; then find_opts_arr+=("-xdev"); fi

    # --- Output main info ---
    if [[ "$is_directory" = true ]]; then
        if [ "$count" = true ]; then
            dir_count=$(find "$path" "${find_opts_arr[@]}" -type d 2>/dev/null | wc -l | awk '{printf "%'\''d\n", $1}')
            file_count=$(find "$path" "${find_opts_arr[@]}" -type f 2>/dev/null | wc -l | awk '{printf "%'\''d\n", $1}')
            echo -e "$path is ${YELLOW}${size_info}${NC} (with ${YELLOW}${file_count} files${NC}, ${YELLOW}${dir_count} directories${NC})"
        else
            echo -e "$path is ${YELLOW}${size_info}${NC}"
        fi
    elif [[ "$is_file" = true ]]; then
        # For a file, count is 1 file, 0 dirs
        count_str=""
        if [[ "$count" = true ]]; then
            count_str=" (with ${YELLOW}1 file${NC}, ${YELLOW}0 directories${NC})"
        fi
        echo -e "$path is ${YELLOW}${size_info}${NC}${count_str}"
    fi

    echo "Located on $device, $use_percent used ($used of $total_size, $available available)"

    # --- Top N Sections ---
    if [[ "$is_directory" = true ]]; then
        # Pre-build du options to use in find commands
        read -ra file_du_opts <<< "$(build_du_options "file")"
        read -ra dir_du_opts <<< "$(build_du_options "summarize")"

        # Top N largest files in root directory (-t)
        if [[ "$top_n_root_files_count" -gt 0 ]]; then
            echo ""
            echo "Top $top_n_root_files_count largest files in $path:"
            top_items=$(find "$path" "${find_opts_arr[@]}" -maxdepth 1 -type f -exec du "${file_du_opts[@]}" {} + 2>/dev/null | sort -rh | head -n "$top_n_root_files_count")
            if [[ -n "$top_items" ]]; then echo "$top_items"; else echo "  (No files found)"; fi
        fi

        # Top N largest subdirectories (-ts)
        if [[ "$top_n_subdirs_count" -gt 0 ]]; then
            echo ""
            echo "Top $top_n_subdirs_count largest subdirectories in $path:"
            top_items=$(find "$path" "${find_opts_arr[@]}" -mindepth 1 -maxdepth 1 -type d -exec du "${dir_du_opts[@]}" {} + 2>/dev/null | sort -rh | head -n "$top_n_subdirs_count")
            if [[ -n "$top_items" ]]; then echo "$top_items"; else echo "  (No subdirectories found)"; fi
        fi

        # Top N largest files in subdirectories (-tsf)
        if [[ "$top_n_subfiles_count" -gt 0 ]]; then
            echo ""
            echo "Top $top_n_subfiles_count largest files in subdirectories of $path:"
            top_items=$(find "$path" "${find_opts_arr[@]}" -mindepth 2 -type f -exec du "${file_du_opts[@]}" {} + 2>/dev/null | sort -rh | head -n "$top_n_subfiles_count")
            if [[ -n "$top_items" ]]; then echo "$top_items"; else echo "  (No files found in subdirectories)"; fi
        fi
    fi
}

# If multiple paths provided, aggregate them
if [[ ${#paths_arr[@]} -gt 1 ]]; then
    # Validate all paths exist first
    valid_paths=()
    for p in "${paths_arr[@]}"; do
        if [[ -e "$p" ]]; then
            valid_paths+=("$p")
        else
            echo "size: Warning: '$p' does not exist, skipping." >&2
        fi
    done
    
    if [[ ${#valid_paths[@]} -eq 0 ]]; then
        echo "size: Error: No valid paths found." >&2
        exit 1
    fi
    
    # Build du options
    read -ra current_du_opts <<< "$(build_du_options "file")"
    
    # Calculate total size using du on all paths
    total_size_bytes=0
    total_files=0
    total_dirs=0
    first_device=""
    
    for p in "${valid_paths[@]}"; do
        if [[ -f "$p" ]]; then
            total_files=$((total_files + 1))
        elif [[ -d "$p" ]]; then
            total_dirs=$((total_dirs + 1))
            if [ "$count" = true ]; then
                # Count files and dirs within this directory
                find_opts_arr=()
                if [ "$xdev_enabled" = true ]; then find_opts_arr+=("-xdev"); fi
                dir_count=$(find "$p" "${find_opts_arr[@]}" -type d 2>/dev/null | wc -l)
                file_count=$(find "$p" "${find_opts_arr[@]}" -type f 2>/dev/null | wc -l)
                total_dirs=$((total_dirs + dir_count - 1)) # -1 to not count the directory itself twice
                total_files=$((total_files + file_count))
            fi
        fi
    done
    
    # Get total size using du - get raw bytes first, then convert
    if [ "$use_apparent_size_default" = true ]; then
        # Use apparent size in bytes
        total_bytes=$(du --apparent-size -sb "${valid_paths[@]}" 2>/dev/null | awk '{sum += $1} END {print sum}')
    else
        # Use disk usage in bytes
        total_bytes=$(du -sb "${valid_paths[@]}" 2>/dev/null | awk '{sum += $1} END {print sum}')
    fi
    
    # Convert to human-readable format
    size_info=$(echo "$total_bytes" | numfmt --to=iec-i --suffix=B 2>/dev/null | sed 's/iB$//' || numfmt --to=iec --suffix= <<< "$total_bytes" 2>/dev/null || echo "${total_bytes}B")
    
    # Get device info from first valid path
    df_path="${valid_paths[0]}"
    if [[ -f "$df_path" ]]; then
        df_path=$(dirname "$df_path")
    fi
    df_output=$(df -hP "$df_path" 2>/dev/null | tail -n 1)
    device=$(echo "$df_output" | awk '{print $1}')
    total_size=$(echo "$df_output" | awk '{print $2}')
    used=$(echo "$df_output" | awk '{print $3}')
    available=$(echo "$df_output" | awk '{print $4}')
    use_percent=$(echo "$df_output" | awk '{print $5}')
    
    # Output summary
    # When multiple paths are provided, create a descriptive message
    if [ "$count" = true ]; then
        formatted_files=$(printf "%'d" $total_files)
        formatted_dirs=$(printf "%'d" $total_dirs)
        echo -e "All files matching pattern are ${YELLOW}${size_info}${NC} (${YELLOW}${formatted_files} files${NC}, ${YELLOW}${formatted_dirs} directories${NC})"
    else
        echo -e "All files matching pattern are ${YELLOW}${size_info}${NC}"
    fi
    echo "Located on $device, $use_percent used ($used of $total_size, $available available)"
    
else
    # Single path - use original logic
    process_path "${paths_arr[0]}" false
fi

# Time taken
end_time=$(date +%s.%N)
elapsed_time_raw=$(echo "$end_time - $start_time" | bc)
elapsed_time_formatted=$(LC_NUMERIC=C printf "%.1f" "$elapsed_time_raw")

if [[ "$elapsed_time_formatted" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
    if (( $(echo "$elapsed_time_formatted >= 10" | bc -l) )); then
        echo "(Script ran for ${elapsed_time_formatted}s)"
    fi
fi

exit 0

