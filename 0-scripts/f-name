#!/usr/bin/env bash
# Author: Roy Wiseman 2025-01
# Updated: 2025-11-06 - Enhanced with fnew-style features and consistent formatting

# ANSI color codes
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
NC='\033[0m' # No Color
WHITE='\033[1;37m'
BOLD='\033[1m'

# --- Help Function ---
show_help() {
cat << EOF
Usage: $(basename "$0") <pattern> [pattern...] [directory] [options]
  pattern:         Search pattern (required). Glob pattern by default (e.g., *.log, test*.txt)
                   Multiple patterns can be specified (finds files matching ANY pattern)
  directory:       Target directory to search (default: current directory).

Options:
  -f, --files      Show only files, no directories
  -d, --dirs       Show only directories, no files
  -i, --ignore-case  Case-insensitive search
  -r, --regex      Treat patterns as regex instead of glob (applies to all patterns)
  -q, --quiet      Suppress summary output (for piping)
  -s, --sudo       Use sudo for find command
  -e, --exclude    Exclude paths matching pattern (can be used multiple times)
                   Example: --exclude .git --exclude node_modules
  -h, --help       Show this help

Note: At least one pattern is required. Directory is optional and can be specified anywhere.
      When using multiple patterns, all must be the same type (all glob or all regex).
Examples:
  $(basename "$0") "*.log"                    # Find all .log files (glob)
  $(basename "$0") "*.sh" "*.py" "*.bash"     # Find shell and Python files
  $(basename "$0") "*.LOG" -i                 # Find .log files case-insensitively
  $(basename "$0") "test*" /var               # Find files starting with "test" in /var
  $(basename "$0") "\.txt$" "\.md$" -r        # Find .txt and .md files using regex
  $(basename "$0") "backup.*" -r -i /home     # Regex search, case-insensitive
  $(basename "$0") "*.mp4" "*.mkv" -f         # Find only video files, not directories
  $(basename "$0") "node_modules" -d          # Find directories named node_modules
  $(basename "$0") "*.tmp" -q | wc -l         # Count tmp files without summary
EOF
}

# Show help if no arguments provided
if [[ $# -eq 0 ]]; then
    show_help
    exit 0
fi

# --- Default values ---
patterns=()
dir="."
use_sudo=""
excludes=()
files_only=false
dirs_only=false
quiet_mode=false
ignore_case=false
use_regex=false

# Function to check if a value looks like a directory
is_directory() {
    [[ -d "$1" ]]
}

# --- Argument Parsing ---
while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            show_help
            exit 0
            ;;
        --sudo|-s)
            use_sudo="sudo"
            shift
            ;;
        --files|-f)
            files_only=true
            shift
            ;;
        --dirs|-d)
            dirs_only=true
            shift
            ;;
        --quiet|-q)
            quiet_mode=true
            shift
            ;;
        --ignore-case|-i)
            ignore_case=true
            shift
            ;;
        --regex|-r)
            use_regex=true
            shift
            ;;
        --exclude|-e)
            if [[ -n "$2" && "$2" != -* ]]; then
                excludes+=("$2")
                shift 2
            else
                echo "Error: --exclude requires a pattern argument"
                exit 1
            fi
            ;;
        -*)
            echo "Error: Unknown option '$1'" >&2
            echo "Use $(basename "$0") -h or --help for usage instructions." >&2
            exit 1
            ;;
        *)
            # Non-flag arguments: could be pattern(s) or directory
            if is_directory "$1"; then
                dir="$1"
            else
                # Treat as a pattern
                patterns+=("$1")
            fi
            shift
            ;;
    esac
done

# Check for conflicting flags
if [[ "$files_only" == true && "$dirs_only" == true ]]; then
    echo "Error: Cannot use both -f/--files and -d/--dirs at the same time"
    exit 1
fi

# --- Basic Input Validation ---
if [[ ${#patterns[@]} -eq 0 ]]; then
    echo "Error: At least one pattern is required." >&2
    echo "Use $(basename "$0") -h or --help for usage instructions." >&2
    exit 1
fi

if [[ ! -d "$dir" ]]; then
    # Check if this looks like a filename (shell-expanded glob)
    if [[ -f "$dir" || "$dir" == *.* ]]; then
        echo "Error: It looks like the shell expanded your pattern." >&2
        echo "       To search for a pattern like *.txt, use quotes:" >&2
        echo "       $(basename "$0") \"*.txt\"" >&2
        echo "" >&2
        echo "       Without quotes, the shell expands *.txt to matching files in the current directory." >&2
        echo "       With quotes, $(basename "$0") searches recursively for the pattern." >&2
    else
        echo "Error: Directory '$dir' not found." >&2
    fi
    echo "Use $(basename "$0") -h or --help for usage instructions." >&2
    exit 1
fi

# Build exclude conditions for find
exclude_args=""
exclude_display=""
for exclude in "${excludes[@]}"; do
    exclude_args="$exclude_args -not -path '*/$exclude/*' -not -path '*/$exclude'"
    exclude_display="$exclude_display -not -path '*/$exclude/*' -not -path '*/$exclude'"
done

# Determine type flag for find command
type_flag=""
type_display=""
if [[ "$files_only" == true ]]; then
    type_flag="-type f"
    type_display=" (files only)"
elif [[ "$dirs_only" == true ]]; then
    type_flag="-type d"
    type_display=" (directories only)"
else
    # Default: show both files and directories
    type_flag=""
    type_display=""
fi

# Determine name flag based on case sensitivity and regex vs glob
name_flag=""
if [[ "$use_regex" == true ]]; then
    if [[ "$ignore_case" == true ]]; then
        name_flag="-iregex"
        pattern_type="regex (case-insensitive)"
    else
        name_flag="-regex"
        pattern_type="regex (case-sensitive)"
    fi
else
    # Glob pattern
    if [[ "$ignore_case" == true ]]; then
        name_flag="-iname"
        pattern_type="glob (case-insensitive)"
    else
        name_flag="-name"
        pattern_type="glob (case-sensitive)"
    fi
fi

# Build the pattern conditions for find with -o (OR) operator
pattern_conditions=""
pattern_conditions_display=""
search_patterns=()

for i in "${!patterns[@]}"; do
    pattern="${patterns[$i]}"
    
    # For regex, prepend .*/ if needed
    if [[ "$use_regex" == true ]]; then
        if [[ ! "$pattern" =~ ^\.\*/ && ! "$pattern" =~ ^/ ]]; then
            search_pattern=".*/$pattern"
        else
            search_pattern="$pattern"
        fi
    else
        search_pattern="$pattern"
    fi
    
    search_patterns+=("$search_pattern")
    
    # Add pattern condition
    if [[ $i -eq 0 ]]; then
        # First pattern: wrap in parentheses if multiple patterns
        if [[ ${#patterns[@]} -gt 1 ]]; then
            pattern_conditions="\\( $name_flag \"$search_pattern\""
            pattern_conditions_display="( $name_flag \"$search_pattern\""
        else
            pattern_conditions="$name_flag \"$search_pattern\""
            pattern_conditions_display="$name_flag \"$search_pattern\""
        fi
    else
        # Additional patterns: add with -o
        pattern_conditions="$pattern_conditions -o $name_flag \"$search_pattern\""
        pattern_conditions_display="$pattern_conditions_display -o $name_flag \"$search_pattern\""
    fi
    
    # Close parentheses for last pattern if multiple
    if [[ $i -eq $((${#patterns[@]} - 1)) && ${#patterns[@]} -gt 1 ]]; then
        pattern_conditions="$pattern_conditions \\)"
        pattern_conditions_display="$pattern_conditions_display )"
    fi
done

# Create display string for patterns
if [[ ${#patterns[@]} -eq 1 ]]; then
    patterns_display="${patterns[0]}"
else
    patterns_display=$(IFS=', '; echo "${patterns[*]}")
fi

# --- Main execution ---

# Start timer (GNU date for %N nanoseconds)
start_time=$(date +%s.%N)

# Find will output Unix timestamp (seconds since epoch, with fractional part) and path
# %T@ provides a sortable timestamp. %p is the path.
find_output_format="%T@ %p\\n"

# Prepare the find command
find_cmd="$use_sudo find \"$dir\" -xdev $type_flag $pattern_conditions$exclude_args -printf '$find_output_format'"

# AWK script to format the timestamp using gawk's built-in 'strftime' function
awk_formatter_script='
{
    timestamp_full = $1;  # First field is the timestamp (e.g., 1609459200.123456)

    # Reconstruct the filepath from the 2nd field to the end
    filepath = "";
    for (i = 2; i <= NF; i++) {
        filepath = filepath (i == 2 ? "" : OFS) $i;
    }

    # Use gawk strftime for formatting. It needs an integer timestamp.
    int_timestamp = int(timestamp_full);

    formatted_date = strftime("%Y-%m-%d %H:%M:%S", int_timestamp);

    print formatted_date " " filepath;
}
'

# Build full display command for summary (simplified for readability)
full_cmd="$use_sudo find \"$dir\" -xdev $type_flag $pattern_conditions_display$exclude_display -printf '%T@ %p\\n' | sort -rnk1,1 | gawk '{awk_formatter_script}'"

# Execute the command pipeline
set -o pipefail # Exit immediately if a command in the pipeline fails
pipeline_output=""
pipeline_exit_status=0

# Execute the full pipeline
pipeline_output=$(eval "$find_cmd" | \
    sort -rnk1,1 | \
    gawk "$awk_formatter_script")
pipeline_exit_status=$?

set +o pipefail # Reset pipefail option

# Print the captured output
if [[ -n "$pipeline_output" ]]; then
    echo "$pipeline_output"
fi

# Count the number of results (handle empty output)
if [[ -n "$pipeline_output" ]]; then
    object_count=$(echo "$pipeline_output" | wc -l)
else
    object_count=0
fi

# Check if the pipeline encountered an issue
if [[ $pipeline_exit_status -ne 0 ]]; then
    if [[ "$quiet_mode" != true ]]; then
        # Status 141 is common if head closes the pipe, often not a critical error if output is present
        if [[ $pipeline_exit_status -eq 141 && -n "$pipeline_output" ]]; then
            # Don't show this info message in normal operation, keep it clean
            :
        elif [[ $pipeline_exit_status -eq 1 ]]; then
            # Exit status 1 usually means permission denied errors
            echo "Note: Some directories were inaccessible (permission denied)." >&2
            echo "      Use -s/--sudo to search all directories." >&2
        else
            echo "Warning: The command pipeline exited with status ${pipeline_exit_status}." >&2
            echo "         This might indicate an issue. Check for errors from 'find', 'sort', or 'gawk'." >&2
        fi
    fi
fi

# End timer and calculate duration with decimal precision
end_time=$(date +%s.%N)
elapsed=$(echo "$end_time - $start_time" | bc)
elapsed_formatted=$(printf "%.2f" $elapsed)

# Display summary only if not in quiet mode
if [[ "$quiet_mode" != true ]]; then
    echo  # Always add exactly one blank line before summary
    echo "Find files by name ($(basename $0) -h for options)"
    printf "${BOLD}# ${NC}${GREEN}%s${NC}\n" "$full_cmd"
    echo -e "Pattern(s): ${YELLOW}${patterns_display}${NC} (${pattern_type})"
    echo -e "Execution time: ${YELLOW}${elapsed_formatted}${NC} seconds"
    echo -e "Objects found: ${YELLOW}${object_count}${NC}$type_display"
fi

