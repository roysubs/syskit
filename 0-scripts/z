#!/bin/bash
# Author: Roy Wiseman 2025-01
# z - Universal Archive Tool
# A unified interface for creating, extracting, and managing archives

set -euo pipefail  # Exit on error, undefined vars, pipe failures
shopt -s extglob nullglob  # Extended globbing and safe empty globs

SCRIPT_NAME=${0##*/}
VERSION="2.0"

# ANSI color codes
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[1;34m'
readonly WHITE='\033[1;37m'
readonly NC='\033[0m'  # No Color

# Configuration
DEFAULT_ARCHIVER="7z"  # Options: 7z, zip
SHOW_CMD_BEFORE_EXEC=true
COMPRESSION_LEVEL=""  # Override with --level=<1-9>
BACKUP_DIR="$HOME/.backups"  # Default backup location
USE_SUDO=false  # For backup operations

# Known archive extensions
declare -A ARCHIVE_EXTENSIONS=(
    [7z]=".7z"
    [zip]=".zip"
    [tar]=".tar"
    [tar.gz]=".tar.gz"
    [tgz]=".tgz"
    [tar.bz2]=".tar.bz2"
    [tbz2]=".tbz2"
    [tar.xz]=".tar.xz"
    [txz]=".txz"
    [tar.zst]=".tar.zst"
    [tzst]=".tzst"
)

# ============================================================================
# Helper Functions
# ============================================================================

print_error() {
    echo -e "${RED}Error: $1${NC}" >&2
}

print_warning() {
    echo -e "${YELLOW}Warning: $1${NC}"
}

print_success() {
    echo -e "${GREEN}✓ $1${NC}"
}

print_info() {
    echo -e "${BLUE}→ $1${NC}"
}

check_command() {
    local cmd_name="$1"
    local critical="${2:-false}"
    
    if ! command -v "$cmd_name" &>/dev/null; then
        if [[ "$critical" == "true" ]]; then
            print_error "Command '$cmd_name' not found. Please install it."
            exit 1
        else
            print_warning "Command '$cmd_name' not found. Some features may be limited."
            return 1
        fi
    fi
    return 0
}

run_command() {
    local display_cmd=""
    
    # Build display string with proper quoting
    for arg in "$@"; do
        if [[ "$arg" =~ [[:space:]] || "$arg" =~ [\!\@\#\$\%\^\&\*\(\)] ]]; then
            display_cmd+="'$arg' "
        else
            display_cmd+="$arg "
        fi
    done
    
    if [[ "$SHOW_CMD_BEFORE_EXEC" == "true" ]]; then
        echo -e "${WHITE}#${NC} ${GREEN}${display_cmd}${NC}"
    fi
    
    "$@"
    local status=$?
    
    if [[ $status -ne 0 ]]; then
        print_error "Command failed with exit code $status"
        return $status
    fi
    
    return 0
}

verify_file_exists() {
    local file="$1"
    if [[ ! -f "$file" ]]; then
        print_error "File not found: $file"
        exit 1
    fi
}

verify_sources_exist() {
    local sources=("$@")
    local missing=()
    
    for src in "${sources[@]}"; do
        if [[ ! -e "$src" ]]; then
            missing+=("$src")
        fi
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        print_error "Source(s) not found: ${missing[*]}"
        exit 1
    fi
}

append_extension_if_needed() {
    local archive="$1"
    local archiver="$2"
    
    # Check if archive already has a known extension
    local has_extension=false
    for ext in "${ARCHIVE_EXTENSIONS[@]}"; do
        if [[ "${archive,,}" == *"$ext" ]]; then
            has_extension=true
            break
        fi
    done
    
    # If no extension, append the default for the archiver
    if [[ "$has_extension" == "false" ]]; then
        case "$archiver" in
            7z) echo "${archive}.7z" ;;
            zip) echo "${archive}.zip" ;;
            *) echo "$archive" ;;
        esac
    else
        echo "$archive"
    fi
}

# ============================================================================
# Help Functions
# ============================================================================

show_help() {
    printf "${BLUE}${SCRIPT_NAME}${NC} v${VERSION} - Universal Archive Tool\n\n"
    printf "${YELLOW}USAGE:${NC}\n"
    printf "    ${SCRIPT_NAME} [options] <command> [arguments]\n\n"
    
    printf "${YELLOW}GLOBAL OPTIONS:${NC}\n"
    printf "    --no-cmd              Don't show native command before execution\n"
    printf "    --archiver <tool>     Force archiver (7z|zip) for add commands\n"
    printf "    --level <1-9>         Set compression level (tool-dependent)\n"
    printf "    --sudo                Use sudo for backup operations (handle permission errors)\n\n"
    
    printf "${YELLOW}COMMANDS:${NC}\n"
    printf "    ${GREEN}Creating Archives:${NC}\n"
    printf "    a, add <archive> <sources...>           Add to archive (recursive, default: ${DEFAULT_ARCHIVER})\n"
    printf "    an, add-nr <archive> <files...>         Add files (non-recursive)\n"
    printf "    az, zip <archive.zip> <sources...>      Create ZIP archive\n"
    printf "    a7, 7z <archive.7z> <sources...>        Create 7z archive\n"
    printf "    atgz <archive.tar.gz> <sources...>      Create .tar.gz archive\n"
    printf "    atbz <archive.tar.bz2> <sources...>     Create .tar.bz2 archive\n"
    printf "    atxz <archive.tar.xz> <sources...>      Create .tar.xz archive\n"
    printf "    atzst <archive.tar.zst> <sources...>    Create .tar.zst archive\n\n"
    
    printf "    ${GREEN}Extracting & Listing:${NC}\n"
    printf "    x, extract <archive> [dest]             Extract archive (auto-detect format)\n"
    printf "    l, list <archive>                       List archive contents\n"
    printf "    t, test <archive>                       Test archive integrity\n\n"
    
    printf "    ${GREEN}Single-File Compression:${NC}\n"
    printf "    g, gzip <files...>                      Compress to .gz (removes original)\n"
    printf "    gu, gunzip <files...>                   Decompress .gz files\n"
    printf "    bz, bzip2 <files...>                    Compress to .bz2\n"
    printf "    bu, bunzip2 <files...>                  Decompress .bz2 files\n"
    printf "    xzc, xz <files...>                      Compress to .xz\n"
    printf "    xzd, unxz <files...>                    Decompress .xz files\n"
    printf "    zstc, zstd <files...>                   Compress to .zst\n"
    printf "    zstd, unzstd <files...>                 Decompress .zst files\n\n"
    
    printf "    ${GREEN}Utility:${NC}\n"
    printf "    backup, bak <folder> [dest_dir]        Create timestamped backup (default: ~/.backups)\n"
    printf "    restore, res <backup.zip> [dest]       Restore a backup archive\n"
    printf "    info <archive>                          Show detailed archive info\n"
    printf "    h, help                                 Show this help\n"
    printf "    hh, examples                            Show usage examples\n\n"
    
    printf "${YELLOW}EXAMPLES:${NC}\n"
    printf "    ${SCRIPT_NAME} a backup.7z /home/docs /etc/config\n"
    printf "    ${SCRIPT_NAME} x archive.zip ~/extracted\n"
    printf "    ${SCRIPT_NAME} l backup.tar.gz\n"
    printf "    ${SCRIPT_NAME} --level 9 az important.zip *.doc\n"
    printf "    ${SCRIPT_NAME} backup ~/important-folder\n"
    printf "    ${SCRIPT_NAME} --sudo backup /etc\n\n"
    
    printf "${YELLOW}SUPPORTED FORMATS:${NC}\n"
    printf "    7z, zip, rar, tar, gz, tgz, bz2, tbz2, xz, txz, zst, tzst, iso, cab, arj...\n\n"
}

show_examples() {
    printf "${BLUE}${SCRIPT_NAME}${NC} - Usage Examples with Native Commands\n\n"
    
    printf "${YELLOW}━━━ CREATING ARCHIVES ━━━${NC}\n\n"
    
    printf "${WHITE}Create a 7z archive (default, recursive):${NC}\n"
    printf "  Native:     7z a backup.7z /home/docs project.txt\n"
    printf "  ${SCRIPT_NAME} eqv: ${GREEN}${SCRIPT_NAME} a backup /home/docs project.txt${NC}\n\n"
    
    printf "${WHITE}Create a ZIP archive:${NC}\n"
    printf "  Native:     zip -r archive.zip folder/ file.txt\n"
    printf "  ${SCRIPT_NAME} eqv: ${GREEN}${SCRIPT_NAME} az archive.zip folder/ file.txt${NC}\n\n"
    
    printf "${WHITE}Create tar.gz (tarball):${NC}\n"
    printf "  Native:     tar -czf archive.tar.gz folder/\n"
    printf "  ${SCRIPT_NAME} eqv: ${GREEN}${SCRIPT_NAME} atgz archive.tar.gz folder/${NC}\n\n"
    
    printf "${WHITE}Add files without recursion:${NC}\n"
    printf "  Native:     zip archive.zip file1.txt file2.txt\n"
    printf "  ${SCRIPT_NAME} eqv: ${GREEN}${SCRIPT_NAME} an archive file1.txt file2.txt${NC}\n\n"
    
    printf "${YELLOW}━━━ EXTRACTING ARCHIVES ━━━${NC}\n\n"
    
    printf "${WHITE}Extract to current directory:${NC}\n"
    printf "  Native:     7z x archive.7z\n"
    printf "  ${SCRIPT_NAME} eqv: ${GREEN}${SCRIPT_NAME} x archive.7z${NC}\n\n"
    
    printf "${WHITE}Extract to specific directory:${NC}\n"
    printf "  Native:     7z x archive.7z -o/path/to/dest\n"
    printf "  ${SCRIPT_NAME} eqv: ${GREEN}${SCRIPT_NAME} x archive.7z /path/to/dest${NC}\n\n"
    
    printf "${WHITE}Extract tar.gz:${NC}\n"
    printf "  Native:     tar -xzf archive.tar.gz\n"
    printf "  ${SCRIPT_NAME} eqv: ${GREEN}${SCRIPT_NAME} x archive.tar.gz${NC}\n\n"
    
    printf "${YELLOW}━━━ LISTING & INFO ━━━${NC}\n\n"
    
    printf "${WHITE}List archive contents:${NC}\n"
    printf "  Native:     7z l archive.7z\n"
    printf "  ${SCRIPT_NAME} eqv: ${GREEN}${SCRIPT_NAME} l archive.7z${NC}\n\n"
    
    printf "${WHITE}Test archive integrity:${NC}\n"
    printf "  Native:     7z t archive.7z\n"
    printf "  ${SCRIPT_NAME} eqv: ${GREEN}${SCRIPT_NAME} t archive.7z${NC}\n\n"
    
    printf "${YELLOW}━━━ SINGLE-FILE COMPRESSION ━━━${NC}\n\n"
    
    printf "${WHITE}Compress with gzip:${NC}\n"
    printf "  Native:     gzip largefile.txt\n"
    printf "  ${SCRIPT_NAME} eqv: ${GREEN}${SCRIPT_NAME} g largefile.txt${NC}\n\n"
    
    printf "${WHITE}Decompress gzip:${NC}\n"
    printf "  Native:     gunzip largefile.txt.gz\n"
    printf "  ${SCRIPT_NAME} eqv: ${GREEN}${SCRIPT_NAME} gu largefile.txt.gz${NC}\n\n"
    
    printf "${WHITE}Compress with xz (best compression):${NC}\n"
    printf "  Native:     xz -9 largefile.bin\n"
    printf "  ${SCRIPT_NAME} eqv: ${GREEN}${SCRIPT_NAME} --level 9 xzc largefile.bin${NC}\n\n"
    
    printf "${YELLOW}━━━ BACKUP & RESTORE ━━━${NC}\n\n"
    
    printf "${WHITE}Create timestamped backup:${NC}\n"
    printf "  Native:     zip -r -9 ~/.backups/folder-2025-01-15_10-30-00.zip folder/\n"
    printf "  ${SCRIPT_NAME} eqv: ${GREEN}${SCRIPT_NAME} backup ~/folder${NC}\n\n"
    
    printf "${WHITE}Backup with sudo (handle permission errors):${NC}\n"
    printf "  Native:     sudo zip -r -9 ~/.backups/etc-2025-01-15_10-30-00.zip /etc\n"
    printf "  ${SCRIPT_NAME} eqv: ${GREEN}${SCRIPT_NAME} --sudo backup /etc${NC}\n\n"
    
    printf "${WHITE}Backup to custom location:${NC}\n"
    printf "  ${SCRIPT_NAME} eqv: ${GREEN}${SCRIPT_NAME} backup ~/docs /mnt/external/backups${NC}\n\n"
    
    printf "${WHITE}Restore a backup:${NC}\n"
    printf "  ${SCRIPT_NAME} eqv: ${GREEN}${SCRIPT_NAME} restore ~/.backups/folder-2025-01-15_10-30-00.zip${NC}\n\n"
}

# ============================================================================
# Archive Operations
# ============================================================================

create_archive() {
    local archiver="$1"
    local archive="$2"
    local recursive="$3"
    shift 3
    local sources=("$@")
    
    verify_sources_exist "${sources[@]}"
    archive=$(append_extension_if_needed "$archive" "$archiver")
    
    case "$archiver" in
        7z)
            check_command "7z" "true"
            local opts=("a")
            [[ -n "$COMPRESSION_LEVEL" ]] && opts+=("-mx=${COMPRESSION_LEVEL}")
            [[ "$recursive" == "false" ]] && opts+=("-r-")
            run_command 7z "${opts[@]}" "$archive" "${sources[@]}"
            ;;
        zip)
            check_command "zip" "true"
            local opts=()
            [[ "$recursive" == "true" ]] && opts+=("-r")
            [[ -n "$COMPRESSION_LEVEL" ]] && opts+=("-${COMPRESSION_LEVEL}")
            run_command zip "${opts[@]}" "$archive" "${sources[@]}"
            ;;
        *)
            print_error "Unknown archiver: $archiver"
            exit 1
            ;;
    esac
    
    print_success "Created archive: $archive"
}

create_tar_archive() {
    local compression="$1"
    local archive="$2"
    shift 2
    local sources=("$@")
    
    check_command "tar" "true"
    verify_sources_exist "${sources[@]}"
    
    # Ensure proper extension
    case "$compression" in
        gz) 
            [[ "${archive,,}" != *.tar.gz && "${archive,,}" != *.tgz ]] && archive="${archive}.tar.gz"
            ;;
        bz2) 
            [[ "${archive,,}" != *.tar.bz2 && "${archive,,}" != *.tbz2 ]] && archive="${archive}.tar.bz2"
            ;;
        xz) 
            [[ "${archive,,}" != *.tar.xz && "${archive,,}" != *.txz ]] && archive="${archive}.tar.xz"
            ;;
        zst) 
            [[ "${archive,,}" != *.tar.zst && "${archive,,}" != *.tzst ]] && archive="${archive}.tar.zst"
            ;;
    esac
    
    local tar_opts="-caf"
    run_command tar $tar_opts "$archive" "${sources[@]}"
    print_success "Created archive: $archive"
}

extract_archive() {
    local archive="$1"
    local dest_dir="${2:-}"
    
    verify_file_exists "$archive"
    
    local file_type
    file_type=$(file -b "$archive")
    local base_name="${archive%%.*}"
    local is_single_compressed=false
    
    # Detect single-file compression formats
    case "${archive,,}" in
        *.gz|*.bz2|*.xz|*.zst)
            if [[ ! "${archive,,}" =~ \.tar\. ]]; then
                is_single_compressed=true
            fi
            ;;
    esac
    
    # Determine destination
    local final_dest=""
    if [[ -n "$dest_dir" ]]; then
        final_dest="$dest_dir"
        mkdir -p "$final_dest" || exit 1
    elif [[ "$is_single_compressed" == "true" ]]; then
        final_dest="."
    else
        final_dest="${base_name}_extracted"
        if [[ -d "$final_dest" ]]; then
            print_warning "Directory '$final_dest' exists. Files may be overwritten."
        fi
        mkdir -p "$final_dest" || exit 1
    fi
    
    print_info "Extracting '$archive' to '$final_dest'..."
    
    local success=false
    
    # Try single-file decompression first
    if [[ "$is_single_compressed" == "true" && "$final_dest" == "." ]]; then
        case "${archive,,}" in
            *.gz)  check_command "gunzip" && run_command gunzip "$archive" && success=true ;;
            *.bz2) check_command "bunzip2" && run_command bunzip2 "$archive" && success=true ;;
            *.xz)  check_command "unxz" && run_command unxz "$archive" && success=true ;;
            *.zst) check_command "unzstd" && run_command unzstd "$archive" && success=true ;;
        esac
    fi
    
    # Try 7z (handles most formats)
    if [[ "$success" == "false" ]] && check_command "7z"; then
        print_info "Using 7z..."
        if run_command 7z x "$archive" "-o${final_dest}"; then
            success=true
        fi
    fi
    
    # Try tar for tar-based archives
    if [[ "$success" == "false" ]] && [[ "$file_type" == *tar* || "${archive,,}" =~ \.(tar|tgz|tbz2?|txz|tzst)$ ]]; then
        if check_command "tar"; then
            print_info "Using tar..."
            local tar_opts=("-xaf" "$archive")
            [[ "$final_dest" != "." ]] && tar_opts+=("-C" "$final_dest")
            if run_command tar "${tar_opts[@]}"; then
                success=true
            fi
        fi
    fi
    
    # Try unzip for ZIP files
    if [[ "$success" == "false" ]] && [[ "$file_type" == *Zip\ archive* || "${archive,,}" == *.zip ]]; then
        if check_command "unzip"; then
            print_info "Using unzip..."
            local unzip_opts=("-q" "$archive")
            [[ "$final_dest" != "." ]] && unzip_opts+=("-d" "$final_dest")
            if run_command unzip "${unzip_opts[@]}"; then
                success=true
            fi
        fi
    fi
    
    if [[ "$success" == "true" ]]; then
        print_success "Extraction completed"
    else
        print_error "Failed to extract '$archive'. Format may be unsupported or tools missing."
        [[ -z "$dest_dir" && "$is_single_compressed" == "false" && -d "$final_dest" && -z "$(ls -A "$final_dest")" ]] && rmdir "$final_dest"
        exit 1
    fi
}

list_archive() {
    local archive="$1"
    verify_file_exists "$archive"
    
    local file_type
    file_type=$(file -b "$archive")
    local success=false
    
    # Try 7z first (handles most formats)
    if check_command "7z"; then
        if run_command 7z l "$archive"; then
            success=true
        fi
    fi
    
    # Try tar
    if [[ "$success" == "false" ]] && [[ "$file_type" == *tar* || "${archive,,}" =~ \.(tar|tgz|tbz2?|txz|tzst)$ ]]; then
        if check_command "tar"; then
            if run_command tar -tvaf "$archive"; then
                success=true
            fi
        fi
    fi
    
    # Try unzip
    if [[ "$success" == "false" ]] && [[ "$file_type" == *Zip\ archive* || "${archive,,}" == *.zip ]]; then
        if check_command "unzip"; then
            if run_command unzip -l "$archive"; then
                success=true
            fi
        fi
    fi
    
    if [[ "$success" == "false" ]]; then
        print_error "Could not list contents of '$archive'"
        exit 1
    fi
}

test_archive() {
    local archive="$1"
    verify_file_exists "$archive"
    
    local success=false
    
    # Try 7z test
    if check_command "7z"; then
        print_info "Testing archive integrity..."
        if run_command 7z t "$archive"; then
            success=true
            print_success "Archive integrity verified"
        fi
    fi
    
    # Try tar test
    if [[ "$success" == "false" ]] && [[ "${archive,,}" =~ \.(tar|tgz|tbz2?|txz|tzst)$ ]]; then
        if check_command "tar"; then
            print_info "Testing archive integrity..."
            if run_command tar -tf "$archive" >/dev/null; then
                success=true
                print_success "Archive integrity verified"
            fi
        fi
    fi
    
    # Try unzip test
    if [[ "$success" == "false" ]] && [[ "${archive,,}" == *.zip ]]; then
        if check_command "unzip"; then
            print_info "Testing archive integrity..."
            if run_command unzip -t "$archive"; then
                success=true
                print_success "Archive integrity verified"
            fi
        fi
    fi
    
    if [[ "$success" == "false" ]]; then
        print_error "Could not test archive or archive is corrupted"
        exit 1
    fi
}

create_backup() {
    local src_path="$1"
    local dest_dir="${2:-$BACKUP_DIR}"
    
    # Expand path properly
    if [[ "$src_path" == "~" ]]; then
        src_path="$HOME"
    elif [[ "$src_path" == ~/* ]]; then
        src_path="$HOME/${src_path#~/}"
    fi
    
    # Convert to absolute path
    src_path=$(realpath "$src_path" 2>/dev/null) || {
        print_error "Cannot resolve path: $src_path"
        exit 1
    }
    
    # Check if it's a directory
    if [[ ! -d "$src_path" ]]; then
        print_error "'$src_path' is not a directory"
        exit 1
    fi
    
    # Check for zip command
    check_command "zip" "true"
    
    # Prepare backup details
    local folder_name=$(basename "$src_path")
    local timestamp=$(date '+%Y-%m-%d_%H-%M-%S')
    local zip_name="${folder_name}-${timestamp}.zip"
    
    # Create destination directory
    mkdir -p "$dest_dir" || {
        print_error "Cannot create backup directory: $dest_dir"
        exit 1
    }
    
    local zip_path="${dest_dir}/${zip_name}"
    
    # Check permissions with a quick test
    local has_permission_issues=false
    if [[ "$USE_SUDO" == "false" ]]; then
        if ! du -sm "$src_path" >/dev/null 2>&1; then
            print_warning "Permission issues detected in '$src_path'"
            if [[ "$USE_SUDO" == "false" ]]; then
                print_info "Consider using --sudo flag to handle permission errors"
                has_permission_issues=true
            fi
        fi
    fi
    
    # Calculate source size
    print_info "Calculating size..."
    local src_size
    if [[ "$USE_SUDO" == "true" ]]; then
        src_size=$(sudo du -sm "$src_path" 2>/dev/null | awk '{print $1}')
    else
        src_size=$(du -sm "$src_path" 2>/dev/null | awk '{print $1}')
    fi
    
    print_info "Backing up: $src_path (${src_size} MB)"
    print_info "Destination: $zip_path"
    
    # Build and run zip command
    local parent_dir=$(dirname "$src_path")
    local folder_name=$(basename "$src_path")
    
    cd "$parent_dir" || exit 1
    
    local zip_cmd=("zip" "-r" "-9" "$zip_path" "$folder_name")
    
    if [[ "$USE_SUDO" == "true" ]]; then
        print_info "Running with sudo..."
        if run_command sudo "${zip_cmd[@]}" 2>&1 | grep -v "adding:"; then
            : # Command output handled by run_command
        fi
    else
        if run_command "${zip_cmd[@]}" 2>&1 | grep -v "adding:"; then
            : # Command output handled by run_command
        fi
    fi
    
    # Check if backup was created
    if [[ ! -f "$zip_path" ]]; then
        print_error "Backup failed - no zip file created"
        exit 1
    fi
    
    # Report results
    local zip_size=$(du -sm "$zip_path" | awk '{print $1}')
    local compression_ratio=$(awk "BEGIN {printf \"%.1f\", ($src_size - $zip_size) / $src_size * 100}")
    
    print_success "Backup created: $zip_path"
    print_info "Original: ${src_size} MB → Compressed: ${zip_size} MB (${compression_ratio}% reduction)"
    
    if [[ "$has_permission_issues" == "true" ]]; then
        print_warning "Some files may have been skipped due to permissions"
    fi
}

show_archive_info() {
    local archive="$1"
    verify_file_exists "$archive"
    
    echo -e "${BLUE}Archive Information:${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "File: $archive"
    echo "Size: $(du -h "$archive" | cut -f1)"
    echo "Type: $(file -b "$archive")"
    echo "Modified: $(stat -c %y "$archive" 2>/dev/null || stat -f %Sm "$archive" 2>/dev/null)"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo
    list_archive "$archive"
}

# ============================================================================
# Single-File Compression Functions
# ============================================================================

compress_files() {
    local tool="$1"
    shift
    local files=("$@")
    
    check_command "$tool" "true"
    
    for file in "${files[@]}"; do
        if [[ -f "$file" ]]; then
            run_command "$tool" "$file"
        else
            print_warning "Skipping non-existent file: $file"
        fi
    done
}

decompress_files() {
    local tool="$1"
    local extension="$2"
    shift 2
    local files=("$@")
    
    check_command "$tool" "true"
    
    for file in "${files[@]}"; do
        if [[ -f "$file" && "${file,,}" == *"$extension" ]]; then
            run_command "$tool" "$file"
        else
            print_warning "Skipping: $file (not a $extension file or doesn't exist)"
        fi
    done
}

# ============================================================================
# Main Script
# ============================================================================

# Check for file command (required)
check_command "file" "true"

# Parse global options
while [[ $# -gt 0 ]]; do
    case "$1" in
        --no-cmd)
            SHOW_CMD_BEFORE_EXEC=false
            shift
            ;;
        --archiver)
            if [[ -z "${2:-}" ]]; then
                print_error "--archiver requires an argument (7z|zip)"
                exit 1
            fi
            DEFAULT_ARCHIVER="$2"
            shift 2
            ;;
        --level)
            if [[ -z "${2:-}" ]]; then
                print_error "--level requires a number (1-9)"
                exit 1
            fi
            COMPRESSION_LEVEL="$2"
            shift 2
            ;;
        --sudo)
            USE_SUDO=true
            shift
            ;;
        -*)
            print_error "Unknown option: $1"
            show_help
            exit 1
            ;;
        *)
            break
            ;;
    esac
done

# Get command
if [[ $# -eq 0 ]]; then
    show_help
    exit 0
fi

COMMAND="$1"
shift

# Execute command
case "$COMMAND" in
    a|add)
        if [[ $# -lt 2 ]]; then
            print_error "'$COMMAND' requires <archive> <sources...>"
            exit 1
        fi
        create_archive "$DEFAULT_ARCHIVER" "$1" "true" "${@:2}"
        ;;
    
    an|add-nr|add-non-recursive)
        if [[ $# -lt 2 ]]; then
            print_error "'$COMMAND' requires <archive> <files...>"
            exit 1
        fi
        create_archive "$DEFAULT_ARCHIVER" "$1" "false" "${@:2}"
        ;;
    
    az|zip)
        if [[ $# -lt 2 ]]; then
            print_error "'$COMMAND' requires <archive.zip> <sources...>"
            exit 1
        fi
        create_archive "zip" "$1" "true" "${@:2}"
        ;;
    
    a7|7z)
        if [[ $# -lt 2 ]]; then
            print_error "'$COMMAND' requires <archive.7z> <sources...>"
            exit 1
        fi
        create_archive "7z" "$1" "true" "${@:2}"
        ;;
    
    atgz|add-tar-gz)
        if [[ $# -lt 2 ]]; then
            print_error "'$COMMAND' requires <archive.tar.gz> <sources...>"
            exit 1
        fi
        create_tar_archive "gz" "$1" "${@:2}"
        ;;
    
    atbz|add-tar-bz2)
        if [[ $# -lt 2 ]]; then
            print_error "'$COMMAND' requires <archive.tar.bz2> <sources...>"
            exit 1
        fi
        create_tar_archive "bz2" "$1" "${@:2}"
        ;;
    
    atxz|add-tar-xz)
        if [[ $# -lt 2 ]]; then
            print_error "'$COMMAND' requires <archive.tar.xz> <sources...>"
            exit 1
        fi
        create_tar_archive "xz" "$1" "${@:2}"
        ;;
    
    atzst|add-tar-zst)
        if [[ $# -lt 2 ]]; then
            print_error "'$COMMAND' requires <archive.tar.zst> <sources...>"
            exit 1
        fi
        create_tar_archive "zst" "$1" "${@:2}"
        ;;
    
    x|extract)
        if [[ $# -lt 1 ]]; then
            print_error "'$COMMAND' requires <archive> [dest_dir]"
            exit 1
        fi
        extract_archive "$1" "${2:-}"
        ;;
    
    l|list)
        if [[ $# -ne 1 ]]; then
            print_error "'$COMMAND' requires <archive>"
            exit 1
        fi
        list_archive "$1"
        ;;
    
    t|test)
        if [[ $# -ne 1 ]]; then
            print_error "'$COMMAND' requires <archive>"
            exit 1
        fi
        test_archive "$1"
        ;;
    
    info)
        if [[ $# -ne 1 ]]; then
            print_error "'$COMMAND' requires <archive>"
            exit 1
        fi
        show_archive_info "$1"
        ;;
    
    backup|bak)
        if [[ $# -lt 1 ]]; then
            print_error "'$COMMAND' requires <folder> [dest_dir]"
            exit 1
        fi
        create_backup "$1" "${2:-}"
        ;;
    
    restore|res)
        if [[ $# -lt 1 ]]; then
            print_error "'$COMMAND' requires <backup.zip> [dest]"
            exit 1
        fi
        print_info "Restoring backup..."
        extract_archive "$1" "${2:-}"
        ;;
    
    g|gzip)
        if [[ $# -lt 1 ]]; then
            print_error "'$COMMAND' requires <files...>"
            exit 1
        fi
        compress_files "gzip" "$@"
        ;;
    
    gu|gunzip)
        if [[ $# -lt 1 ]]; then
            print_error "'$COMMAND' requires <files...>"
            exit 1
        fi
        decompress_files "gunzip" ".gz" "$@"
        ;;
    
    bz|bzip2)
        if [[ $# -lt 1 ]]; then
            print_error "'$COMMAND' requires <files...>"
            exit 1
        fi
        compress_files "bzip2" "$@"
        ;;
    
    bu|bunzip2)
        if [[ $# -lt 1 ]]; then
            print_error "'$COMMAND' requires <files...>"
            exit 1
        fi
        decompress_files "bunzip2" ".bz2" "$@"
        ;;
    
    xzc|xz)
        if [[ $# -lt 1 ]]; then
            print_error "'$COMMAND' requires <files...>"
            exit 1
        fi
        compress_files "xz" "$@"
        ;;
    
    xzd|unxz)
        if [[ $# -lt 1 ]]; then
            print_error "'$COMMAND' requires <files...>"
            exit 1
        fi
        decompress_files "unxz" ".xz" "$@"
        ;;
    
    zstc|zstd)
        if [[ $# -lt 1 ]]; then
            print_error "'$COMMAND' requires <files...>"
            exit 1
        fi
        compress_files "zstd" "$@"
        ;;
    
    zstd|unzstd)
        if [[ $# -lt 1 ]]; then
            print_error "'$COMMAND' requires <files...>"
            exit 1
        fi
        decompress_files "unzstd" ".zst" "$@"
        ;;
    
    h|help)
        show_help
        ;;
    
    hh|examples)
        show_examples
        ;;
    
    *)
        print_error "Unknown command: $COMMAND"
        echo
        show_help
        exit 1
        ;;
esac

exit 0

